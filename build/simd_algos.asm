; Listing generated by Microsoft (R) Optimizing Compiler Version 19.32.31328.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	GlobalTimer
PUBLIC	GlobalRNG
PUBLIC	SIMDTEST_TRUE_STR
PUBLIC	SIMDTEST_FALSE_STR
PUBLIC	gElementCount
PUBLIC	gAlignment
PUBLIC	gSeed
_BSS	SEGMENT
GlobalTimer DB	010H DUP (?)
GlobalRNG DB	010H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
SIMDTEST_TRUE_STR DQ FLAT:$SG73339
$SG73339 DB	'true', 00H
	ORG $+3
SIMDTEST_FALSE_STR DQ FLAT:$SG73341
$SG73341 DB	'false', 00H
	ORG $+2
gElementCount DQ 0000000000989680H
gAlignment DQ	0000000000000010H
gSeed	DD	01dH
_DATA	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	printf
PUBLIC	_vsscanf_l
PUBLIC	vsscanf
PUBLIC	GetLogicalCoreCount
PUBLIC	KillProcess
PUBLIC	TimerInit
PUBLIC	TimerGetTick
PUBLIC	TimerGetSecondsElepsed
PUBLIC	ThreadCreate
PUBLIC	ThreadKill
PUBLIC	ThreadSync
PUBLIC	ThreadBeginWork
PUBLIC	ThreadCreateEvent
PUBLIC	ThreadWaitForEventSignal
PUBLIC	LockedAddAndGetLastValue
PUBLIC	LockedSetAndGetLastValue
PUBLIC	MemAlloc
PUBLIC	MemFree
PUBLIC	ArenaInit
PUBLIC	ArenaAlloc
PUBLIC	ArenaFree
PUBLIC	ArenaPushBlock
PUBLIC	SquareRoot
PUBLIC	FileGetSize
PUBLIC	FileReadAll
PUBLIC	FileWrite
PUBLIC	ConvertStrToValue
PUBLIC	MemoryCopy
PUBLIC	MemoryClear
PUBLIC	EntropyGen
PUBLIC	RandInit
PUBLIC	RandRangeU64
PUBLIC	RandRangeU32
PUBLIC	RandRangeU8
PUBLIC	RandF64Uni
PUBLIC	RandF64Range
PUBLIC	RandF64Bi
PUBLIC	BooleanAsString
PUBLIC	MemoryIsAligned
PUBLIC	FillArrayU8
PUBLIC	ArrayIsValid
PUBLIC	Scalar_MeanU8
PUBLIC	Avx_MeanU8
PUBLIC	ArrayInit
PUBLIC	main
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ca0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@bff0000000000000
EXTRN	__acrt_iob_func:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsscanf:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_CreateFileA:PROC
EXTRN	__imp_GetFileSizeEx:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_WriteFile:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	__imp_WaitForMultipleObjects:PROC
EXTRN	__imp_ExitProcess:PROC
EXTRN	__imp_CreateThread:PROC
EXTRN	__imp_ExitThread:PROC
EXTRN	__imp_GetSystemInfo:PROC
EXTRN	__imp_GetLogicalProcessorInformationEx:PROC
EXTRN	__imp_VirtualAlloc:PROC
EXTRN	__imp_VirtualFree:PROC
EXTRN	__imp_CryptAcquireContextA:PROC
EXTRN	__imp_CryptReleaseContext:PROC
EXTRN	__imp_CryptGenRandom:PROC
EXTRN	sqrt:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+87
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vsscanf DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$vsscanf
pdata	ENDS
pdata	SEGMENT
$pdata$GetLogicalCoreCount DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$GetLogicalCoreCount
$pdata$KillProcess DD imagerel $LN3
	DD	imagerel $LN3+20
	DD	imagerel $unwind$KillProcess
$pdata$TimerInit DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$TimerInit
$pdata$TimerGetTick DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$TimerGetTick
$pdata$TimerGetSecondsElepsed DD imagerel $LN8
	DD	imagerel $LN8+164
	DD	imagerel $unwind$TimerGetSecondsElepsed
$pdata$ThreadCreate DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$ThreadCreate
$pdata$ThreadKill DD imagerel $LN3
	DD	imagerel $LN3+17
	DD	imagerel $unwind$ThreadKill
$pdata$ThreadSync DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$ThreadSync
$pdata$ThreadBeginWork DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$ThreadBeginWork
$pdata$ThreadCreateEvent DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$ThreadCreateEvent
$pdata$ThreadWaitForEventSignal DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$ThreadWaitForEventSignal
$pdata$LockedAddAndGetLastValue DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$LockedAddAndGetLastValue
$pdata$LockedSetAndGetLastValue DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$LockedSetAndGetLastValue
$pdata$MemAlloc DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$MemAlloc
$pdata$MemFree DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$MemFree
$pdata$ArenaInit DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$ArenaInit
$pdata$ArenaAlloc DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$ArenaAlloc
$pdata$ArenaFree DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$ArenaFree
$pdata$ArenaPushBlock DD imagerel $LN7
	DD	imagerel $LN7+180
	DD	imagerel $unwind$ArenaPushBlock
$pdata$SquareRoot DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$SquareRoot
$pdata$FileGetSize DD imagerel $LN7
	DD	imagerel $LN7+112
	DD	imagerel $unwind$FileGetSize
$pdata$FileReadAll DD imagerel $LN8
	DD	imagerel $LN8+331
	DD	imagerel $unwind$FileReadAll
$pdata$FileWrite DD imagerel $LN5
	DD	imagerel $LN5+210
	DD	imagerel $unwind$FileWrite
$pdata$ConvertStrToValue DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$ConvertStrToValue
$pdata$MemoryCopy DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$MemoryCopy
$pdata$MemoryClear DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$MemoryClear
$pdata$EntropyGen DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$EntropyGen
$pdata$pcg64_next DD imagerel pcg64_next
	DD	imagerel pcg64_next+552
	DD	imagerel $unwind$pcg64_next
$pdata$pcg64_range DD imagerel pcg64_range
	DD	imagerel pcg64_range+410
	DD	imagerel $unwind$pcg64_range
$pdata$pcg64_nextd DD imagerel pcg64_nextd
	DD	imagerel pcg64_nextd+51
	DD	imagerel $unwind$pcg64_nextd
$pdata$pcg64_seed DD imagerel pcg64_seed
	DD	imagerel pcg64_seed+233
	DD	imagerel $unwind$pcg64_seed
$pdata$RandInit DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$RandInit
$pdata$RandRangeU64 DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$RandRangeU64
$pdata$RandRangeU32 DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$RandRangeU32
$pdata$RandRangeU8 DD imagerel $LN3
	DD	imagerel $LN3+53
	DD	imagerel $unwind$RandRangeU8
$pdata$RandF64Uni DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$RandF64Uni
$pdata$RandF64Range DD imagerel $LN7
	DD	imagerel $LN7+144
	DD	imagerel $unwind$RandF64Range
$pdata$RandF64Bi DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$RandF64Bi
$pdata$BooleanAsString DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$BooleanAsString
$pdata$MemoryIsAligned DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$MemoryIsAligned
$pdata$FillArrayU8 DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$FillArrayU8
$pdata$ArrayIsValid DD imagerel $LN7
	DD	imagerel $LN7+99
	DD	imagerel $unwind$ArrayIsValid
$pdata$Scalar_MeanU8 DD imagerel $LN11
	DD	imagerel $LN11+252
	DD	imagerel $unwind$Scalar_MeanU8
$pdata$Avx_MeanU8 DD imagerel $LN11
	DD	imagerel $LN11+1072
	DD	imagerel $unwind$Avx_MeanU8
$pdata$ArrayInit DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$ArrayInit
$pdata$main DD	imagerel $LN6
	DD	imagerel $LN6+820
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3ca0000000000000
CONST	SEGMENT
__real@3ca0000000000000 DQ 03ca0000000000000r	; 1.11022e-16
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
_DATA	SEGMENT
$SG73464 DB	'%d', 0aH, 00H
$SG71206 DB	'work begin signal set.', 0aH, 00H
$SG71207 DB	'Error setting work queue begin signal.', 0aH, 00H
$SG71282 DB	'arena capacity is too small for resquested allocation', 00H
	ORG $+2
$SG71283 DB	'Invalid Codepath', 00H
	ORG $+3
$SG71339 DB	'error', 00H
	ORG $+2
$SG73465 DB	0aH, 00H
	ORG $+2
$SG73463 DB	'Array[]: ', 0aH, 00H
	ORG $+5
$SG73466 DB	'Results for Avx_MeanU8', 0aH, 00H
$SG73467 DB	'Result[Avx   ]: %s', 0aH, 00H
	ORG $+4
$SG73468 DB	'Sum   [Avx   ]: %llu', 0aH, 00H
	ORG $+2
$SG73469 DB	'Mean  [Avx   ]: %f', 0aH, 00H
	ORG $+4
$SG73470 DB	0aH, 'Results for Scalar_MeanU8', 0aH, 00H
	ORG $+4
$SG73471 DB	'Result[Scalar]: %s', 0aH, 00H
	ORG $+4
$SG73472 DB	'Sum   [Scalar]: %llu', 0aH, 00H
	ORG $+2
$SG73473 DB	'Mean  [Scalar]: %f', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LockedSetAndGetLastValue
	DD	018H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LockedAddAndGetLastValue
	DD	018H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	011H
	DD	031cH
voltbl	ENDS
xdata	SEGMENT
$unwind$GetLogicalCoreCount DD 030901H
	DD	0160109H
	DD	07002H
$unwind$KillProcess DD 010401H
	DD	04204H
$unwind$TimerInit DD 020601H
	DD	070025206H
$unwind$TimerGetTick DD 020601H
	DD	070025206H
$unwind$TimerGetSecondsElepsed DD 010e01H
	DD	0620eH
$unwind$ThreadCreate DD 010e01H
	DD	0820eH
$unwind$ThreadKill DD 010401H
	DD	04204H
$unwind$ThreadSync DD 010d01H
	DD	0420dH
$unwind$ThreadBeginWork DD 010901H
	DD	04209H
$unwind$ThreadCreateEvent DD 010901H
	DD	06209H
$unwind$ThreadWaitForEventSignal DD 010901H
	DD	04209H
$unwind$LockedAddAndGetLastValue DD 010e01H
	DD	0220eH
$unwind$LockedSetAndGetLastValue DD 010e01H
	DD	0220eH
$unwind$MemAlloc DD 010901H
	DD	06209H
$unwind$MemFree DD 010901H
	DD	04209H
$unwind$ArenaInit DD 031501H
	DD	070114215H
	DD	06010H
$unwind$ArenaAlloc DD 031001H
	DD	0700ca210H
	DD	0600bH
$unwind$ArenaFree DD 010901H
	DD	04209H
$unwind$ArenaPushBlock DD 010e01H
	DD	0820eH
$unwind$SquareRoot DD 010a01H
	DD	0620aH
$unwind$FileGetSize DD 020a01H
	DD	07006720aH
$unwind$FileReadAll DD 041801H
	DD	0110118H
	DD	060107011H
$unwind$FileWrite DD 031a01H
	DD	07016c21aH
	DD	06015H
$unwind$ConvertStrToValue DD 011801H
	DD	06218H
$unwind$MemoryCopy DD 011301H
	DD	04213H
$unwind$MemoryClear DD 010e01H
	DD	0420eH
$unwind$EntropyGen DD 010e01H
	DD	0820eH
$unwind$pcg64_next DD 010901H
	DD	0a209H
$unwind$pcg64_range DD 021601H
	DD	0130116H
$unwind$pcg64_nextd DD 010901H
	DD	06209H
$unwind$pcg64_seed DD 011301H
	DD	06213H
$unwind$RandInit DD 010401H
	DD	06204H
$unwind$RandRangeU64 DD 010e01H
	DD	0620eH
$unwind$RandRangeU32 DD 010c01H
	DD	0620cH
$unwind$RandRangeU8 DD 010c01H
	DD	0620cH
$unwind$RandF64Uni DD 010401H
	DD	06204H
$unwind$RandF64Range DD 011001H
	DD	08210H
$unwind$RandF64Bi DD 010401H
	DD	06204H
$unwind$BooleanAsString DD 010801H
	DD	02208H
$unwind$MemoryIsAligned DD 010e01H
	DD	0220eH
$unwind$FillArrayU8 DD 011801H
	DD	06218H
$unwind$ArrayIsValid DD 010e01H
	DD	0420eH
$unwind$Scalar_MeanU8 DD 011801H
	DD	06218H
$unwind$Avx_MeanU8 DD 021b01H
	DD	01b011bH
$unwind$ArrayInit DD 011301H
	DD	08213H
$unwind$main DD	021919H
	DD	0170107H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vsscanf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
i$1 = 32
ResultB$ = 36
ResultA$ = 40
Count$ = 48
SumB$ = 56
MeanB$ = 64
SumA$ = 72
MeanA$ = 80
Array$ = 96
__$ArrayPad$ = 160
main	PROC

; 152  : {

$LN6:
	sub	rsp, 184				; 000000b8H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 153  : #if 0
; 154  :   RandInit();
; 155  :   arena Arena = ArenaAlloc(Kilobytes(4000)+ELEM_MAXCOUNT*sizeof(uint8_t));
; 156  :   printf("Is Aligned? [%#llx] %s\n", (uint64_t)Arena.Base, BooleanAsString(MemoryIsAligned(Arena.Base, 16)));
; 157  :   uint64_t Count = 64;
; 158  :   uint8_t *Array = ArenaPushArray(&Arena, Count, uint8_t);
; 159  :   ArrayInit(Array, Count, gSeed);
; 160  : #endif
; 161  :   
; 162  :   uint8_t Array[] =

	mov	BYTE PTR Array$[rsp], 5
	mov	BYTE PTR Array$[rsp+1], 224		; 000000e0H
	mov	BYTE PTR Array$[rsp+2], 125		; 0000007dH
	mov	BYTE PTR Array$[rsp+3], 150		; 00000096H
	mov	BYTE PTR Array$[rsp+4], 221		; 000000ddH
	mov	BYTE PTR Array$[rsp+5], 12
	mov	BYTE PTR Array$[rsp+6], 140		; 0000008cH
	mov	BYTE PTR Array$[rsp+7], 145		; 00000091H
	mov	BYTE PTR Array$[rsp+8], 114		; 00000072H
	mov	BYTE PTR Array$[rsp+9], 68		; 00000044H
	mov	BYTE PTR Array$[rsp+10], 20
	mov	BYTE PTR Array$[rsp+11], 206		; 000000ceH
	mov	BYTE PTR Array$[rsp+12], 203		; 000000cbH
	mov	BYTE PTR Array$[rsp+13], 186		; 000000baH
	mov	BYTE PTR Array$[rsp+14], 27
	mov	BYTE PTR Array$[rsp+15], 225		; 000000e1H
	mov	BYTE PTR Array$[rsp+16], 38		; 00000026H
	mov	BYTE PTR Array$[rsp+17], 213		; 000000d5H
	mov	BYTE PTR Array$[rsp+18], 90		; 0000005aH
	mov	BYTE PTR Array$[rsp+19], 6
	mov	BYTE PTR Array$[rsp+20], 66		; 00000042H
	mov	BYTE PTR Array$[rsp+21], 118		; 00000076H
	mov	BYTE PTR Array$[rsp+22], 143		; 0000008fH
	mov	BYTE PTR Array$[rsp+23], 25
	mov	BYTE PTR Array$[rsp+24], 6
	mov	BYTE PTR Array$[rsp+25], 27
	mov	BYTE PTR Array$[rsp+26], 7
	mov	BYTE PTR Array$[rsp+27], 227		; 000000e3H
	mov	BYTE PTR Array$[rsp+28], 56		; 00000038H
	mov	BYTE PTR Array$[rsp+29], 65		; 00000041H
	mov	BYTE PTR Array$[rsp+30], 17
	mov	BYTE PTR Array$[rsp+31], 135		; 00000087H
	mov	BYTE PTR Array$[rsp+32], 90		; 0000005aH
	mov	BYTE PTR Array$[rsp+33], 145		; 00000091H
	mov	BYTE PTR Array$[rsp+34], 132		; 00000084H
	mov	BYTE PTR Array$[rsp+35], 51		; 00000033H
	mov	BYTE PTR Array$[rsp+36], 185		; 000000b9H
	mov	BYTE PTR Array$[rsp+37], 150		; 00000096H
	mov	BYTE PTR Array$[rsp+38], 158		; 0000009eH
	mov	BYTE PTR Array$[rsp+39], 235		; 000000ebH
	mov	BYTE PTR Array$[rsp+40], 103		; 00000067H
	mov	BYTE PTR Array$[rsp+41], 120		; 00000078H
	mov	BYTE PTR Array$[rsp+42], 158		; 0000009eH
	mov	BYTE PTR Array$[rsp+43], 80		; 00000050H
	mov	BYTE PTR Array$[rsp+44], 51		; 00000033H
	mov	BYTE PTR Array$[rsp+45], 184		; 000000b8H
	mov	BYTE PTR Array$[rsp+46], 18
	mov	BYTE PTR Array$[rsp+47], 74		; 0000004aH
	mov	BYTE PTR Array$[rsp+48], 235		; 000000ebH
	mov	BYTE PTR Array$[rsp+49], 158		; 0000009eH
	mov	BYTE PTR Array$[rsp+50], 182		; 000000b6H
	mov	BYTE PTR Array$[rsp+51], 60		; 0000003cH
	mov	BYTE PTR Array$[rsp+52], 108		; 0000006cH
	mov	BYTE PTR Array$[rsp+53], 157		; 0000009dH
	mov	BYTE PTR Array$[rsp+54], 206		; 000000ceH
	mov	BYTE PTR Array$[rsp+55], 153		; 00000099H
	mov	BYTE PTR Array$[rsp+56], 76		; 0000004cH
	mov	BYTE PTR Array$[rsp+57], 176		; 000000b0H
	mov	BYTE PTR Array$[rsp+58], 16
	mov	BYTE PTR Array$[rsp+59], 152		; 00000098H
	mov	BYTE PTR Array$[rsp+60], 20
	mov	BYTE PTR Array$[rsp+61], 128		; 00000080H
	mov	BYTE PTR Array$[rsp+62], 85		; 00000055H
	mov	BYTE PTR Array$[rsp+63], 35		; 00000023H

; 163  :   {   5, 224, 125, 150, 221, 12, 140, 145, 114, 68, 20, 206,
; 164  :     203, 186, 27, 225, 38, 213, 90, 6, 66, 118, 143, 25, 6,
; 165  :     27, 7, 227, 56, 65, 17, 135, 90, 145, 132, 51, 185, 150,
; 166  :     158, 235, 103, 120, 158, 80, 51, 184, 18, 74, 235, 158,
; 167  :     182, 60, 108, 157, 206, 153, 76, 176, 16, 152, 20, 128, 85, 35};
; 168  :   uint64_t Count = ArrayCount(Array);

	mov	QWORD PTR Count$[rsp], 64		; 00000040H

; 169  :   uint32_t ResultA = 0;

	mov	DWORD PTR ResultA$[rsp], 0

; 170  :   uint32_t ResultB = 0;

	mov	DWORD PTR ResultB$[rsp], 0

; 171  :   uint64_t SumA = 0;

	mov	QWORD PTR SumA$[rsp], 0

; 172  :   uint64_t SumB = 0;

	mov	QWORD PTR SumB$[rsp], 0

; 173  :   double MeanA = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR MeanA$[rsp], xmm0

; 174  :   double MeanB = 0.0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR MeanB$[rsp], xmm0

; 175  :   
; 176  :   printf("Array[]: \n");

	lea	rcx, OFFSET FLAT:$SG73463
	call	printf

; 177  :   for(int i=0;i<Count;i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@main
$LN2@main:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@main:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR Count$[rsp]
	jae	SHORT $LN3@main

; 178  :   {
; 179  :     printf("%d\n", Array[i]);

	movsxd	rax, DWORD PTR i$1[rsp]
	movzx	eax, BYTE PTR Array$[rsp+rax]
	mov	edx, eax
	lea	rcx, OFFSET FLAT:$SG73464
	call	printf

; 180  :   }

	jmp	SHORT $LN2@main
$LN3@main:

; 181  :   
; 182  :   ResultB = Avx_MeanU8(&MeanB, &SumB, Array, Count);

	mov	r9, QWORD PTR Count$[rsp]
	lea	r8, QWORD PTR Array$[rsp]
	lea	rdx, QWORD PTR SumB$[rsp]
	lea	rcx, QWORD PTR MeanB$[rsp]
	call	Avx_MeanU8
	mov	DWORD PTR ResultB$[rsp], eax

; 183  :   printf("\n");

	lea	rcx, OFFSET FLAT:$SG73465
	call	printf

; 184  :   printf("Results for Avx_MeanU8\n");

	lea	rcx, OFFSET FLAT:$SG73466
	call	printf

; 185  :   printf("Result[Avx   ]: %s\n", BooleanAsString(ResultB));

	mov	ecx, DWORD PTR ResultB$[rsp]
	call	BooleanAsString
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG73467
	call	printf

; 186  :   printf("Sum   [Avx   ]: %llu\n", SumB);

	mov	rdx, QWORD PTR SumB$[rsp]
	lea	rcx, OFFSET FLAT:$SG73468
	call	printf

; 187  :   printf("Mean  [Avx   ]: %f\n", MeanB);

	movsd	xmm1, QWORD PTR MeanB$[rsp]
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:$SG73469
	call	printf

; 188  :   
; 189  :   ResultA = Scalar_MeanU8(&MeanA, &SumA, Array, Count);

	mov	r9, QWORD PTR Count$[rsp]
	lea	r8, QWORD PTR Array$[rsp]
	lea	rdx, QWORD PTR SumA$[rsp]
	lea	rcx, QWORD PTR MeanA$[rsp]
	call	Scalar_MeanU8
	mov	DWORD PTR ResultA$[rsp], eax

; 190  :   printf("\nResults for Scalar_MeanU8\n");

	lea	rcx, OFFSET FLAT:$SG73470
	call	printf

; 191  :   printf("Result[Scalar]: %s\n", BooleanAsString(ResultA));

	mov	ecx, DWORD PTR ResultA$[rsp]
	call	BooleanAsString
	mov	rdx, rax
	lea	rcx, OFFSET FLAT:$SG73471
	call	printf

; 192  :   printf("Sum   [Scalar]: %llu\n", SumA);

	mov	rdx, QWORD PTR SumA$[rsp]
	lea	rcx, OFFSET FLAT:$SG73472
	call	printf

; 193  :   printf("Mean  [Scalar]: %f\n", MeanA);

	movsd	xmm1, QWORD PTR MeanA$[rsp]
	movq	rdx, xmm1
	lea	rcx, OFFSET FLAT:$SG73473
	call	printf

; 194  :   
; 195  :   //ArenaFree(&Arena);
; 196  :   //TODO(): Make sure that array is initialized correctly
; 197  :   //TODO(): Make sure that array is aligned
; 198  :   //TODO(): Make sure that array is checked. something jpeg algos and 
; 199  :   return;
; 200  : }

	xor	eax, eax
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 184				; 000000b8H
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
RngMaxVal$ = 48
RngMinVal$ = 52
Array$ = 80
Size$ = 88
Seed$ = 96
ArrayInit PROC

; 137  : {

$LN3:
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 138  :   int32_t RngMinVal = 5;

	mov	DWORD PTR RngMinVal$[rsp], 5

; 139  :   int32_t RngMaxVal = 250;

	mov	DWORD PTR RngMaxVal$[rsp], 250		; 000000faH

; 140  :   FillArrayU8(Array, Size, RngMinVal, RngMaxVal, Seed);

	mov	eax, DWORD PTR Seed$[rsp]
	mov	DWORD PTR [rsp+32], eax
	movzx	r9d, BYTE PTR RngMaxVal$[rsp]
	movzx	r8d, BYTE PTR RngMinVal$[rsp]
	mov	rdx, QWORD PTR Size$[rsp]
	mov	rcx, QWORD PTR Array$[rsp]
	call	FillArrayU8

; 141  : #if 0
; 142  :   Array[(Count/4)*3 + 1] = 2;
; 143  :   Array[(Count/4)+11] = 3;
; 144  :   Array[(Count/2)] = 252;
; 145  :   Array[(Count/2) + 13] = 253;
; 146  :   Array[(Count/8) + 5] = 253;
; 147  :   Array[(Count/8) + 7] = 254;
; 148  : #endif
; 149  :   return;
; 150  : }

	add	rsp, 72					; 00000048H
	ret	0
ArrayInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
packoffset$1 = 32
PixelSumsU16$2 = 48
PixelSum$ = 64
i$3 = 72
PixelValsU8$4 = 80
PackedZero$ = 96
SimdElmCount$ = 112
PixelSumsU32$ = 128
PixelValsLoU16$5 = 144
PixelValsHiU16$6 = 160
PixelSumsLoU32$7 = 176
PixelSumsHiU32$8 = 192
Mean$ = 224
Sum$ = 232
Array$ = 240
Count$ = 248
Avx_MeanU8 PROC

; 61   : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 216				; 000000d8H

; 62   :   if(!ArrayIsValid(Array, Count)) return SIMDTEST_FALSE;

	mov	rdx, QWORD PTR Count$[rsp]
	mov	rcx, QWORD PTR Array$[rsp]
	call	ArrayIsValid
	test	eax, eax
	jne	SHORT $LN5@Avx_MeanU8
	xor	eax, eax
	jmp	$LN1@Avx_MeanU8
$LN5@Avx_MeanU8:

; 63   :   
; 64   :   const uint64_t SimdElmCount = 16;

	mov	QWORD PTR SimdElmCount$[rsp], 16

; 65   :   __m128i PackedZero   = _mm_setzero_si128();

	pxor	xmm0, xmm0
	movdqa	XMMWORD PTR PackedZero$[rsp], xmm0

; 66   :   __m128i PixelSumsU32 = _mm_setzero_si128();

	pxor	xmm0, xmm0
	movdqa	XMMWORD PTR PixelSumsU32$[rsp], xmm0

; 67   :   for(uint64_t i=0;i<Count; i+=SimdElmCount*4)

	mov	QWORD PTR i$3[rsp], 0
	jmp	SHORT $LN4@Avx_MeanU8
$LN2@Avx_MeanU8:
	mov	rax, QWORD PTR i$3[rsp]
	mov	rcx, QWORD PTR SimdElmCount$[rsp]
	lea	rax, QWORD PTR [rax+rcx*4]
	mov	QWORD PTR i$3[rsp], rax
$LN4@Avx_MeanU8:
	mov	rax, QWORD PTR Count$[rsp]
	cmp	QWORD PTR i$3[rsp], rax
	jae	$LN3@Avx_MeanU8

; 68   :   {
; 69   :     __m128i PixelValsU8;
; 70   :     __m128i PixelValsLoU16;
; 71   :     __m128i PixelValsHiU16;
; 72   :     __m128i PixelSumsU16 = _mm_setzero_si128();

	pxor	xmm0, xmm0
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 73   :     // Unpacking Result which is a 16bit element
; 74   :     // Hi 8bits(PackedZero)  Lo 8Bits(Pixel)
; 75   :     // 00000000              10101010 <-random example
; 76   :     uint64_t packoffset = 0;

	mov	QWORD PTR packoffset$1[rsp], 0

; 77   :     PixelValsU8 = _mm_load_si128((__m128i*)&Array[i+packoffset]);

	mov	rax, QWORD PTR packoffset$1[rsp]
	mov	rcx, QWORD PTR i$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR Array$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movdqu	xmm0, XMMWORD PTR [rax]
	movdqa	XMMWORD PTR PixelValsU8$4[rsp], xmm0

; 78   :     PixelValsLoU16 = _mm_unpacklo_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpcklbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsLoU16$5[rsp], xmm0

; 79   :     PixelValsHiU16 = _mm_unpackhi_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpckhbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsHiU16$6[rsp], xmm0

; 80   :     // It seems like the goals is to load using simd by using the input data size
; 81   :     // and using unpacking opperations to promote the size of the opperands.
; 82   :     // the size that we are using for operations must give rooom for the maximum
; 83   :     // result that can possible be computed from the data set and our operations.
; 84   :     // we need enough bits to represent the result.
; 85   :     // the result in this case is summ and it is divided int to 8 16bit elements
; 86   :     // in other words we are doing 8 sums at the same time.
; 87   :     // also taking on smaller chunks at a time lets us use more lanes
; 88   :     // which can then be merged into fewer but wider lanes via unpacking
; 89   :     // 
; 90   :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsLoU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsLoU16$5[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 91   :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsHiU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsHiU16$6[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 92   :     packoffset += SimdElmCount;

	mov	rax, QWORD PTR SimdElmCount$[rsp]
	mov	rcx, QWORD PTR packoffset$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR packoffset$1[rsp], rax

; 93   :     
; 94   :     PixelValsU8 = _mm_load_si128((__m128i*)&Array[i+packoffset]);

	mov	rax, QWORD PTR packoffset$1[rsp]
	mov	rcx, QWORD PTR i$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR Array$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movdqu	xmm0, XMMWORD PTR [rax]
	movdqa	XMMWORD PTR PixelValsU8$4[rsp], xmm0

; 95   :     PixelValsLoU16 = _mm_unpacklo_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpcklbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsLoU16$5[rsp], xmm0

; 96   :     PixelValsHiU16 = _mm_unpackhi_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpckhbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsHiU16$6[rsp], xmm0

; 97   :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsLoU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsLoU16$5[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 98   :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsHiU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsHiU16$6[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 99   :     packoffset += SimdElmCount;

	mov	rax, QWORD PTR SimdElmCount$[rsp]
	mov	rcx, QWORD PTR packoffset$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR packoffset$1[rsp], rax

; 100  :     
; 101  :     PixelValsU8 = _mm_load_si128((__m128i*)&Array[i+packoffset]);

	mov	rax, QWORD PTR packoffset$1[rsp]
	mov	rcx, QWORD PTR i$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR Array$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movdqu	xmm0, XMMWORD PTR [rax]
	movdqa	XMMWORD PTR PixelValsU8$4[rsp], xmm0

; 102  :     PixelValsLoU16 = _mm_unpacklo_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpcklbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsLoU16$5[rsp], xmm0

; 103  :     PixelValsHiU16 = _mm_unpackhi_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpckhbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsHiU16$6[rsp], xmm0

; 104  :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsLoU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsLoU16$5[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 105  :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsHiU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsHiU16$6[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 106  :     packoffset += SimdElmCount;

	mov	rax, QWORD PTR SimdElmCount$[rsp]
	mov	rcx, QWORD PTR packoffset$1[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR packoffset$1[rsp], rax

; 107  :     
; 108  :     PixelValsU8 = _mm_load_si128((__m128i*)&Array[i+packoffset]);

	mov	rax, QWORD PTR packoffset$1[rsp]
	mov	rcx, QWORD PTR i$3[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	rcx, QWORD PTR Array$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movdqu	xmm0, XMMWORD PTR [rax]
	movdqa	XMMWORD PTR PixelValsU8$4[rsp], xmm0

; 109  :     PixelValsLoU16 = _mm_unpacklo_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpcklbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsLoU16$5[rsp], xmm0

; 110  :     PixelValsHiU16 = _mm_unpackhi_epi8(PixelValsU8, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelValsU8$4[rsp]
	punpckhbw xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelValsHiU16$6[rsp], xmm0

; 111  :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsLoU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsLoU16$5[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 112  :     PixelSumsU16    = _mm_add_epi16(PixelSumsU16, PixelValsHiU16);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	paddw	xmm0, XMMWORD PTR PixelValsHiU16$6[rsp]
	movdqa	XMMWORD PTR PixelSumsU16$2[rsp], xmm0

; 113  :     // it seems that sumation is done by taking groups from the array promoting the the size
; 114  :     // and summing up the groups individualy into a list of sums(8x 16bit sums) then merging the list of sums
; 115  :     // by promoting size of the sums and and adding them(or collapsing them into a smaller list of wider sums)(4x 32bit sums)
; 116  :     // then finally collapsing them via additions to the result of a single 64bit sum
; 117  :     __m128i PixelSumsLoU32 = _mm_unpacklo_epi16(PixelSumsU16, PackedZero); //Take low 4 of PixelU16

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	punpcklwd xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelSumsLoU32$7[rsp], xmm0

; 118  :     __m128i PixelSumsHiU32 = _mm_unpackhi_epi16(PixelSumsU16, PackedZero);

	movdqa	xmm0, XMMWORD PTR PixelSumsU16$2[rsp]
	punpckhwd xmm0, XMMWORD PTR PackedZero$[rsp]
	movdqa	XMMWORD PTR PixelSumsHiU32$8[rsp], xmm0

; 119  :     
; 120  :     
; 121  :     PixelSumsU32 = _mm_add_epi32(PixelSumsU32 ,PixelSumsLoU32);

	movdqa	xmm0, XMMWORD PTR PixelSumsU32$[rsp]
	paddd	xmm0, XMMWORD PTR PixelSumsLoU32$7[rsp]
	movdqa	XMMWORD PTR PixelSumsU32$[rsp], xmm0

; 122  :     PixelSumsU32 = _mm_add_epi32(PixelSumsU32 ,PixelSumsHiU32);

	movdqa	xmm0, XMMWORD PTR PixelSumsU32$[rsp]
	paddd	xmm0, XMMWORD PTR PixelSumsHiU32$8[rsp]
	movdqa	XMMWORD PTR PixelSumsU32$[rsp], xmm0

; 123  :   }

	jmp	$LN2@Avx_MeanU8
$LN3@Avx_MeanU8:

; 124  :   
; 125  :   // extract looks pretty similar to an array access using an index
; 126  :   // the bit width per element is 32 in this case and the second arg is the index
; 127  :   // and instead of an array is just i28bit simd register
; 128  :   uint64_t PixelSum = _mm_extract_epi32(PixelSumsU32, 0);

	movdqa	xmm0, XMMWORD PTR PixelSumsU32$[rsp]
	pextrd	eax, xmm0, 0
	cdqe
	mov	QWORD PTR PixelSum$[rsp], rax

; 129  :   PixelSum += _mm_extract_epi32(PixelSumsU32, 1);

	movdqa	xmm0, XMMWORD PTR PixelSumsU32$[rsp]
	pextrd	eax, xmm0, 1
	cdqe
	mov	rcx, QWORD PTR PixelSum$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR PixelSum$[rsp], rax

; 130  :   PixelSum += _mm_extract_epi32(PixelSumsU32, 2);

	movdqa	xmm0, XMMWORD PTR PixelSumsU32$[rsp]
	pextrd	eax, xmm0, 2
	cdqe
	mov	rcx, QWORD PTR PixelSum$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR PixelSum$[rsp], rax

; 131  :   PixelSum += _mm_extract_epi32(PixelSumsU32, 3);

	movdqa	xmm0, XMMWORD PTR PixelSumsU32$[rsp]
	pextrd	eax, xmm0, 3
	cdqe
	mov	rcx, QWORD PTR PixelSum$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR PixelSum$[rsp], rax

; 132  :   WriteToRef(Sum, PixelSum);

	mov	rax, QWORD PTR Sum$[rsp]
	mov	rcx, QWORD PTR PixelSum$[rsp]
	mov	QWORD PTR [rax], rcx

; 133  :   WriteToRef(Mean, (double)PixelSum/(double)Count);

	mov	rax, QWORD PTR PixelSum$[rsp]
	test	rax, rax
	jl	SHORT $LN9@Avx_MeanU8
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN10@Avx_MeanU8
$LN9@Avx_MeanU8:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN10@Avx_MeanU8:
	mov	rax, QWORD PTR Count$[rsp]
	test	rax, rax
	jl	SHORT $LN7@Avx_MeanU8
	cvtsi2sd xmm1, rax
	jmp	SHORT $LN8@Avx_MeanU8
$LN7@Avx_MeanU8:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm2, rcx
	addsd	xmm2, xmm2
	movaps	xmm1, xmm2
$LN8@Avx_MeanU8:
	divsd	xmm0, xmm1
	mov	rax, QWORD PTR Mean$[rsp]
	movsd	QWORD PTR [rax], xmm0

; 134  :   return SIMDTEST_TRUE;

	mov	eax, 1
$LN1@Avx_MeanU8:

; 135  : }

	add	rsp, 216				; 000000d8H
	ret	0
Avx_MeanU8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
i$1 = 32
SumTemp$ = 40
Mean$ = 64
Sum$ = 72
Array$ = 80
Count$ = 88
Scalar_MeanU8 PROC

; 52   : {

$LN11:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 53   :   if(!ArrayIsValid(Array, Count)) return SIMDTEST_FALSE;

	mov	rdx, QWORD PTR Count$[rsp]
	mov	rcx, QWORD PTR Array$[rsp]
	call	ArrayIsValid
	test	eax, eax
	jne	SHORT $LN5@Scalar_Mea
	xor	eax, eax
	jmp	$LN1@Scalar_Mea
$LN5@Scalar_Mea:

; 54   :   uint64_t SumTemp = 0;

	mov	QWORD PTR SumTemp$[rsp], 0

; 55   :   for(uint64_t i=0;i<Count;i++) { SumTemp += Array[i]; }

	mov	QWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@Scalar_Mea
$LN2@Scalar_Mea:
	mov	rax, QWORD PTR i$1[rsp]
	inc	rax
	mov	QWORD PTR i$1[rsp], rax
$LN4@Scalar_Mea:
	mov	rax, QWORD PTR Count$[rsp]
	cmp	QWORD PTR i$1[rsp], rax
	jae	SHORT $LN3@Scalar_Mea
	mov	rax, QWORD PTR i$1[rsp]
	mov	rcx, QWORD PTR Array$[rsp]
	add	rcx, rax
	mov	rax, rcx
	movzx	eax, BYTE PTR [rax]
	mov	rcx, QWORD PTR SumTemp$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR SumTemp$[rsp], rax
	jmp	SHORT $LN2@Scalar_Mea
$LN3@Scalar_Mea:

; 56   :   WriteToRef(Sum, SumTemp);

	mov	rax, QWORD PTR Sum$[rsp]
	mov	rcx, QWORD PTR SumTemp$[rsp]
	mov	QWORD PTR [rax], rcx

; 57   :   WriteToRef(Mean, (double)SumTemp/(double)Count);

	mov	rax, QWORD PTR SumTemp$[rsp]
	test	rax, rax
	jl	SHORT $LN9@Scalar_Mea
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN10@Scalar_Mea
$LN9@Scalar_Mea:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN10@Scalar_Mea:
	mov	rax, QWORD PTR Count$[rsp]
	test	rax, rax
	jl	SHORT $LN7@Scalar_Mea
	cvtsi2sd xmm1, rax
	jmp	SHORT $LN8@Scalar_Mea
$LN7@Scalar_Mea:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm2, rcx
	addsd	xmm2, xmm2
	movaps	xmm1, xmm2
$LN8@Scalar_Mea:
	divsd	xmm0, xmm1
	mov	rax, QWORD PTR Mean$[rsp]
	movsd	QWORD PTR [rax], xmm0

; 58   :   return SIMDTEST_TRUE;

	mov	eax, 1
$LN1@Scalar_Mea:

; 59   : }

	add	rsp, 56					; 00000038H
	ret	0
Scalar_MeanU8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
Array$ = 48
Count$ = 56
ArrayIsValid PROC

; 45   : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 46   :   if((Count==0) || (Count>ELEM_MAXCOUNT)) return SIMDTEST_FALSE;

	cmp	QWORD PTR Count$[rsp], 0
	je	SHORT $LN3@ArrayIsVal
	cmp	QWORD PTR Count$[rsp], 67108864		; 04000000H
	jbe	SHORT $LN2@ArrayIsVal
$LN3@ArrayIsVal:
	xor	eax, eax
	jmp	SHORT $LN1@ArrayIsVal
$LN2@ArrayIsVal:

; 47   :   if((Count%64) != 0)                     return SIMDTEST_FALSE;

	xor	edx, edx
	mov	rax, QWORD PTR Count$[rsp]
	mov	ecx, 64					; 00000040H
	div	rcx
	mov	rax, rdx
	test	rax, rax
	je	SHORT $LN4@ArrayIsVal
	xor	eax, eax
	jmp	SHORT $LN1@ArrayIsVal
$LN4@ArrayIsVal:

; 48   :   if(!MemoryIsAligned(Array, gAlignment)) return SIMDTEST_FALSE;

	mov	rdx, QWORD PTR gAlignment
	mov	rcx, QWORD PTR Array$[rsp]
	call	MemoryIsAligned
	test	eax, eax
	jne	SHORT $LN5@ArrayIsVal
	xor	eax, eax
	jmp	SHORT $LN1@ArrayIsVal
$LN5@ArrayIsVal:

; 49   :   return SIMDTEST_TRUE;

	mov	eax, 1
$LN1@ArrayIsVal:

; 50   : }

	add	rsp, 40					; 00000028H
	ret	0
ArrayIsValid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
i$1 = 32
Dest$ = 40
Array$ = 64
Count$ = 72
min$ = 80
max$ = 88
seed$ = 96
FillArrayU8 PROC

; 35   : {

$LN6:
	mov	BYTE PTR [rsp+32], r9b
	mov	BYTE PTR [rsp+24], r8b
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 36   :   uint8_t *Dest = (uint8_t *)Array;

	mov	rax, QWORD PTR Array$[rsp]
	mov	QWORD PTR Dest$[rsp], rax

; 37   :   for(int i=0;i<Count;i++)

	mov	DWORD PTR i$1[rsp], 0
	jmp	SHORT $LN4@FillArrayU
$LN2@FillArrayU:
	mov	eax, DWORD PTR i$1[rsp]
	inc	eax
	mov	DWORD PTR i$1[rsp], eax
$LN4@FillArrayU:
	movsxd	rax, DWORD PTR i$1[rsp]
	cmp	rax, QWORD PTR Count$[rsp]
	jae	SHORT $LN3@FillArrayU

; 38   :   {
; 39   :     Dest[i] = RandRangeU8(min, max);

	movzx	edx, BYTE PTR max$[rsp]
	movzx	ecx, BYTE PTR min$[rsp]
	call	RandRangeU8
	movsxd	rcx, DWORD PTR i$1[rsp]
	mov	rdx, QWORD PTR Dest$[rsp]
	mov	BYTE PTR [rdx+rcx], al

; 40   :   }

	jmp	SHORT $LN2@FillArrayU
$LN3@FillArrayU:

; 41   :   return;
; 42   : }

	add	rsp, 56					; 00000038H
	ret	0
FillArrayU8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
tv66 = 0
Result$ = 4
Address$ = 8
Pointer$ = 32
Alignment$ = 40
MemoryIsAligned PROC

; 29   : {

$LN5:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 30   :   uint64_t Address = (uint64_t)Pointer;

	mov	rax, QWORD PTR Pointer$[rsp]
	mov	QWORD PTR Address$[rsp], rax

; 31   :   uint32_t Result = ((Address%Alignment)==0);

	xor	edx, edx
	mov	rax, QWORD PTR Address$[rsp]
	div	QWORD PTR Alignment$[rsp]
	mov	rax, rdx
	test	rax, rax
	jne	SHORT $LN3@MemoryIsAl
	mov	DWORD PTR tv66[rsp], 1
	jmp	SHORT $LN4@MemoryIsAl
$LN3@MemoryIsAl:
	mov	DWORD PTR tv66[rsp], 0
$LN4@MemoryIsAl:
	mov	eax, DWORD PTR tv66[rsp]
	mov	DWORD PTR Result$[rsp], eax

; 32   :   return Result;

	mov	eax, DWORD PTR Result$[rsp]

; 33   : }

	add	rsp, 24
	ret	0
MemoryIsAligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\test\simd_algos.c
_TEXT	SEGMENT
tv65 = 0
Result$ = 8
Bool$ = 32
BooleanAsString PROC

; 23   : {

$LN5:
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 24

; 24   :   //Assert that it is a valid boolean value
; 25   :   const char *Result = Bool?SIMDTEST_TRUE_STR:SIMDTEST_FALSE_STR;

	cmp	DWORD PTR Bool$[rsp], 0
	je	SHORT $LN3@BooleanAsS
	mov	rax, QWORD PTR SIMDTEST_TRUE_STR
	mov	QWORD PTR tv65[rsp], rax
	jmp	SHORT $LN4@BooleanAsS
$LN3@BooleanAsS:
	mov	rax, QWORD PTR SIMDTEST_FALSE_STR
	mov	QWORD PTR tv65[rsp], rax
$LN4@BooleanAsS:
	mov	rax, QWORD PTR tv65[rsp]
	mov	QWORD PTR Result$[rsp], rax

; 26   :   return Result;

	mov	rax, QWORD PTR Result$[rsp]

; 27   : }

	add	rsp, 24
	ret	0
BooleanAsString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
r$ = 32
RandF64Bi PROC

; 289  : {

$LN3:
	sub	rsp, 56					; 00000038H

; 290  :   double r = RandF64Range(-1.0,1.0);

	movsd	xmm1, QWORD PTR __real@3ff0000000000000
	movsd	xmm0, QWORD PTR __real@bff0000000000000
	call	RandF64Range
	movsd	QWORD PTR r$[rsp], xmm0

; 291  :   return r;

	movsd	xmm0, QWORD PTR r$[rsp]

; 292  : }

	add	rsp, 56					; 00000038H
	ret	0
RandF64Bi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
tv65 = 32
d$ = 40
t$ = 48
r$ = 56
low$ = 80
high$ = 88
RandF64Range PROC

; 281  : {

$LN7:
	movsd	QWORD PTR [rsp+16], xmm1
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 72					; 00000048H
$LN2@RandF64Ran:

; 282  :   Assert(low<=high);

	movsd	xmm0, QWORD PTR low$[rsp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	jp	SHORT $LN5@RandF64Ran
	jne	SHORT $LN5@RandF64Ran
	mov	DWORD PTR tv65[rsp], 1
	jmp	SHORT $LN6@RandF64Ran
$LN5@RandF64Ran:
	mov	DWORD PTR tv65[rsp], 0
$LN6@RandF64Ran:
	cvtsi2sd xmm0, DWORD PTR tv65[rsp]
	movsd	xmm1, QWORD PTR high$[rsp]
	comisd	xmm1, xmm0
	jb	SHORT $LN3@RandF64Ran
	int	3
	jmp	SHORT $LN2@RandF64Ran
$LN3@RandF64Ran:

; 283  :   double d = high-low;

	movsd	xmm0, QWORD PTR high$[rsp]
	subsd	xmm0, QWORD PTR low$[rsp]
	movsd	QWORD PTR d$[rsp], xmm0

; 284  :   double t = RandF64Uni();

	call	RandF64Uni
	movsd	QWORD PTR t$[rsp], xmm0

; 285  :   double r = low + d*t;

	movsd	xmm0, QWORD PTR d$[rsp]
	mulsd	xmm0, QWORD PTR t$[rsp]
	movsd	xmm1, QWORD PTR low$[rsp]
	addsd	xmm1, xmm0
	movaps	xmm0, xmm1
	movsd	QWORD PTR r$[rsp], xmm0

; 286  :   return r;

	movsd	xmm0, QWORD PTR r$[rsp]

; 287  : }

	add	rsp, 72					; 00000048H
	ret	0
RandF64Range ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
r$ = 32
RandF64Uni PROC

; 276  : {

$LN3:
	sub	rsp, 56					; 00000038H

; 277  :   double r = pcg64_nextd(&GlobalRNG);

	lea	rcx, OFFSET FLAT:GlobalRNG
	call	pcg64_nextd
	movsd	QWORD PTR r$[rsp], xmm0

; 278  :   return r;

	movsd	xmm0, QWORD PTR r$[rsp]

; 279  : }

	add	rsp, 56					; 00000038H
	ret	0
RandF64Uni ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
r$ = 32
Low$ = 64
High$ = 72
RandRangeU8 PROC

; 271  : {

$LN3:
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 56					; 00000038H

; 272  :   uint8_t r = (uint8_t)pcg64_range(&GlobalRNG, Low, High);

	movzx	eax, BYTE PTR High$[rsp]
	movzx	ecx, BYTE PTR Low$[rsp]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:GlobalRNG
	call	pcg64_range
	mov	BYTE PTR r$[rsp], al

; 273  :   return r;

	movzx	eax, BYTE PTR r$[rsp]

; 274  : }

	add	rsp, 56					; 00000038H
	ret	0
RandRangeU8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
r$ = 32
Low$ = 64
High$ = 72
RandRangeU32 PROC

; 266  : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 267  :   uint32_t r = (uint32_t)pcg64_range(&GlobalRNG, Low, High);

	mov	eax, DWORD PTR High$[rsp]
	mov	ecx, DWORD PTR Low$[rsp]
	mov	r8d, eax
	mov	edx, ecx
	lea	rcx, OFFSET FLAT:GlobalRNG
	call	pcg64_range
	mov	DWORD PTR r$[rsp], eax

; 268  :   return r;

	mov	eax, DWORD PTR r$[rsp]

; 269  : }

	add	rsp, 56					; 00000038H
	ret	0
RandRangeU32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
r$ = 32
Low$ = 64
High$ = 72
RandRangeU64 PROC

; 261  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 262  :   uint64_t r = pcg64_range(&GlobalRNG, Low, High);

	mov	r8, QWORD PTR High$[rsp]
	mov	rdx, QWORD PTR Low$[rsp]
	lea	rcx, OFFSET FLAT:GlobalRNG
	call	pcg64_range
	mov	QWORD PTR r$[rsp], rax

; 263  :   return r;

	mov	rax, QWORD PTR r$[rsp]

; 264  : }

	add	rsp, 56					; 00000038H
	ret	0
RandRangeU64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
ResultB$ = 32
ResultA$ = 40
RandInit PROC

; 251  : {

$LN3:
	sub	rsp, 56					; 00000038H

; 252  :   //sets seed generator seed
; 253  :   uint64_t ResultA = 0;

	mov	QWORD PTR ResultA$[rsp], 0

; 254  :   uint64_t ResultB = 0;

	mov	QWORD PTR ResultB$[rsp], 0

; 255  :   EntropyGen(&ResultA, sizeof(uint64_t));

	mov	edx, 8
	lea	rcx, QWORD PTR ResultA$[rsp]
	call	EntropyGen

; 256  :   EntropyGen(&ResultB, sizeof(uint64_t));

	mov	edx, 8
	lea	rcx, QWORD PTR ResultB$[rsp]
	call	EntropyGen

; 257  :   pcg64_seed(&GlobalRNG, ResultA, ResultB);

	mov	r8, QWORD PTR ResultB$[rsp]
	mov	rdx, QWORD PTR ResultA$[rsp]
	lea	rcx, OFFSET FLAT:GlobalRNG
	call	pcg64_seed

; 258  :   return;
; 259  : }

	add	rsp, 56					; 00000038H
	ret	0
RandInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\thirdparty\pcg\pcg64.h
_TEXT	SEGMENT
seed$ = 32
rng$ = 64
seed_high$ = 72
seed_low$ = 80
pcg64_seed PROC

; 174  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 175  :   pcg64_uint128 seed = PCG64_INIT( seed_high, seed_low );

	mov	rax, QWORD PTR seed_low$[rsp]
	mov	QWORD PTR seed$[rsp], rax
	mov	rax, QWORD PTR seed_high$[rsp]
	mov	QWORD PTR seed$[rsp+8], rax

; 176  :   
; 177  :   PCG64_ZERO(rng->state);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR rng$[rsp]
	mov	QWORD PTR [rcx+rax], 0
	mov	eax, 8
	imul	rax, rax, 0
	mov	rcx, QWORD PTR rng$[rsp]
	mov	QWORD PTR [rcx+rax], 0

; 178  :   pcg64_next(rng);

	mov	rcx, QWORD PTR rng$[rsp]
	call	pcg64_next

; 179  :   PCG64_ADD(rng->state, seed);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rcx, QWORD PTR rng$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r8d, 8
	imul	r8, r8, 0
	mov	r9, QWORD PTR rng$[rsp]
	add	r9, r8
	mov	r8, r9
	mov	r9d, 8
	imul	r9, r9, 0
	mov	r10d, 8
	imul	r10, r10, 0
	mov	r11, QWORD PTR rng$[rsp]
	mov	r10, QWORD PTR [r11+r10]
	add	r10, QWORD PTR seed$[rsp+r9]
	setb	r9b
	mov	QWORD PTR [r8], r10
	mov	r8, QWORD PTR rng$[rsp]
	mov	rdx, QWORD PTR [r8+rdx]
	movzx	r8d, r9b
	add	r8b, -1
	adc	rdx, QWORD PTR seed$[rsp+rcx]
	mov	QWORD PTR [rax], rdx

; 180  :   pcg64_next(rng);

	mov	rcx, QWORD PTR rng$[rsp]
	call	pcg64_next

; 181  : }

	add	rsp, 56					; 00000038H
	ret	0
pcg64_seed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\thirdparty\pcg\pcg64.h
_TEXT	SEGMENT
x$ = 32
rng$ = 64
pcg64_nextd PROC

; 168  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 169  :   uint64_t x = pcg64_next(rng);

	mov	rcx, QWORD PTR rng$[rsp]
	call	pcg64_next
	mov	QWORD PTR x$[rsp], rax

; 170  :   return (double)(int64_t)(x >> 11) * 0x1.0p-53;

	mov	rax, QWORD PTR x$[rsp]
	shr	rax, 11
	cvtsi2sd xmm0, rax
	mulsd	xmm0, QWORD PTR __real@3ca0000000000000

; 171  : }

	add	rsp, 56					; 00000038H
	ret	0
pcg64_nextd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\thirdparty\pcg\pcg64.h
_TEXT	SEGMENT
t2$ = 32
bound$ = 48
tv161 = 56
tv69 = 64
tv155 = 72
tv79 = 80
r2h$ = 88
r1$ = 104
r2$ = 120
rng$ = 160
low$ = 168
high$ = 176
pcg64_range PROC

; 124  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 152				; 00000098H

; 125  :   uint64_t bound = high - low;

	mov	rax, QWORD PTR low$[rsp]
	mov	rcx, QWORD PTR high$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR bound$[rsp], rax

; 126  :   
; 127  : #if 1
; 128  :   
; 129  :   // An optimal algorithm for bounded random integers: https://github.com/apple/swift/pull/39143
; 130  :   
; 131  :   pcg64_uint128 r1, r2;
; 132  :   PCG64_MUL2(r1, pcg64_next(rng), bound);

	mov	eax, 8
	imul	rax, rax, 1
	lea	rax, QWORD PTR r1$[rsp+rax]
	mov	QWORD PTR tv69[rsp], rax
	mov	rcx, QWORD PTR rng$[rsp]
	call	pcg64_next
	mov	QWORD PTR tv161[rsp], rax
	mov	rcx, QWORD PTR bound$[rsp]
	mov	rax, rcx
	mov	rcx, QWORD PTR tv161[rsp]
	mul	rcx
	mov	rcx, QWORD PTR tv69[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR r1$[rsp+rcx], rax

; 133  :   PCG64_MUL2(r2, pcg64_next(rng), bound);

	mov	eax, 8
	imul	rax, rax, 1
	lea	rax, QWORD PTR r2$[rsp+rax]
	mov	QWORD PTR tv79[rsp], rax
	mov	rcx, QWORD PTR rng$[rsp]
	call	pcg64_next
	mov	QWORD PTR tv155[rsp], rax
	mov	rcx, QWORD PTR bound$[rsp]
	mov	rax, rcx
	mov	rcx, QWORD PTR tv155[rsp]
	mul	rcx
	mov	rcx, QWORD PTR tv79[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR r2$[rsp+rcx], rax

; 134  :   
; 135  :   pcg64_uint128 t2 = PCG64_INIT( 0, PCG64_LOW(r1) );

	mov	eax, 8
	imul	rax, rax, 0
	mov	rax, QWORD PTR r1$[rsp+rax]
	mov	QWORD PTR t2$[rsp], rax
	mov	QWORD PTR t2$[rsp+8], 0

; 136  :   pcg64_uint128 r2h = PCG64_INIT( 0, PCG64_HIGH(r2) );

	mov	eax, 8
	imul	rax, rax, 1
	mov	rax, QWORD PTR r2$[rsp+rax]
	mov	QWORD PTR r2h$[rsp], rax
	mov	QWORD PTR r2h$[rsp+8], 0

; 137  :   PCG64_ADD(t2, r2h);

	mov	eax, 8
	imul	rax, rax, 1
	lea	rax, QWORD PTR t2$[rsp+rax]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r8d, 8
	imul	r8, r8, 0
	lea	r8, QWORD PTR t2$[rsp+r8]
	mov	r9d, 8
	imul	r9, r9, 0
	mov	r10d, 8
	imul	r10, r10, 0
	mov	r10, QWORD PTR t2$[rsp+r10]
	add	r10, QWORD PTR r2h$[rsp+r9]
	setb	r9b
	mov	QWORD PTR [r8], r10
	mov	rdx, QWORD PTR t2$[rsp+rdx]
	movzx	r8d, r9b
	add	r8b, -1
	adc	rdx, QWORD PTR r2h$[rsp+rcx]
	mov	QWORD PTR [rax], rdx

; 138  :   
; 139  :   return low + PCG64_HIGH(r1) + PCG64_HIGH(t2);

	mov	eax, 8
	imul	rax, rax, 1
	mov	rax, QWORD PTR r1$[rsp+rax]
	mov	rcx, QWORD PTR low$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	ecx, 8
	imul	rcx, rcx, 1
	add	rax, QWORD PTR t2$[rsp+rcx]

; 140  :   
; 141  : #else
; 142  :   // Fast Random Integer Generation in an Interval: https://arxiv.org/abs/1805.10941
; 143  :   pcg64_uint128 m;
; 144  :   PCG64_MUL2(m, pcg64_next(rng), bound);
; 145  :   uint64_t l = PCG64_LOW(m);
; 146  :   if (l < bound)
; 147  :   {
; 148  :     uint64_t t = -(int64_t)bound % bound;
; 149  :     while (l < t)
; 150  :     {
; 151  :       PCG64_MUL2(m, pcg64_next(rng), bound);
; 152  :       l = PCG64_LOW(m);
; 153  :     }
; 154  :   }
; 155  :   return low + PCG64_HIGH(m);
; 156  : #endif
; 157  : }

	add	rsp, 152				; 00000098H
	ret	0
pcg64_range ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\thirdparty\pcg\pcg64.h
_TEXT	SEGMENT
rot$ = 0
tv89 = 8
_temp$1 = 16
value$ = 24
state$ = 32
state_mul$ = 48
state_add$ = 64
rng$ = 96
pcg64_next PROC

; 105  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 106  :   pcg64_uint128 state_mul = PCG64_INIT( PCG_DEFAULT_MULTIPLIER_128_H, PCG_DEFAULT_MULTIPLIER_128_L );

	mov	rax, 4865540595714422341		; 4385df649fccf645H
	mov	QWORD PTR state_mul$[rsp], rax
	mov	rax, 2549297995355413924		; 2360ed051fc65da4H
	mov	QWORD PTR state_mul$[rsp+8], rax

; 107  :   pcg64_uint128 state_add = PCG64_INIT( PCG_DEFAULT_INCREMENT_128_H, PCG_DEFAULT_INCREMENT_128_L );

	mov	rax, 1442695040888963407		; 14057b7ef767814fH
	mov	QWORD PTR state_add$[rsp], rax
	mov	rax, 6364136223846793005		; 5851f42d4c957f2dH
	mov	QWORD PTR state_add$[rsp+8], rax

; 108  :   
; 109  :   pcg64_uint128 state;
; 110  :   PCG64_COPY(state, rng->state);

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR rng$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	mov	QWORD PTR state$[rsp+rcx], rax
	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR rng$[rsp]
	mov	rax, QWORD PTR [rdx+rax]
	mov	QWORD PTR state$[rsp+rcx], rax

; 111  :   PCG64_MUL(state, state_mul);

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rax, QWORD PTR state$[rsp+rax]
	imul	rax, QWORD PTR state_mul$[rsp+rcx]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	rcx, QWORD PTR state$[rsp+rcx]
	imul	rcx, QWORD PTR state_mul$[rsp+rdx]
	add	rax, rcx
	mov	QWORD PTR _temp$1[rsp], rax
	mov	eax, 8
	imul	rax, rax, 1
	lea	rax, QWORD PTR state$[rsp+rax]
	mov	QWORD PTR tv89[rsp], rax
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	edx, 8
	imul	rdx, rdx, 0
	mov	rdx, QWORD PTR state$[rsp+rdx]
	mov	rcx, QWORD PTR state_mul$[rsp+rcx]
	mov	rax, rcx
	mul	rdx
	mov	rcx, QWORD PTR tv89[rsp]
	mov	QWORD PTR [rcx], rdx
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	QWORD PTR state$[rsp+rcx], rax
	mov	eax, 8
	imul	rax, rax, 1
	mov	rax, QWORD PTR state$[rsp+rax]
	add	rax, QWORD PTR _temp$1[rsp]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	QWORD PTR state$[rsp+rcx], rax

; 112  :   PCG64_ADD(state, state_add);

	mov	eax, 8
	imul	rax, rax, 1
	lea	rax, QWORD PTR state$[rsp+rax]
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	edx, 8
	imul	rdx, rdx, 1
	mov	r8d, 8
	imul	r8, r8, 0
	lea	r8, QWORD PTR state$[rsp+r8]
	mov	r9d, 8
	imul	r9, r9, 0
	mov	r10d, 8
	imul	r10, r10, 0
	mov	r10, QWORD PTR state$[rsp+r10]
	add	r10, QWORD PTR state_add$[rsp+r9]
	setb	r9b
	mov	QWORD PTR [r8], r10
	mov	rdx, QWORD PTR state$[rsp+rdx]
	movzx	r8d, r9b
	add	r8b, -1
	adc	rdx, QWORD PTR state_add$[rsp+rcx]
	mov	QWORD PTR [rax], rdx

; 113  :   PCG64_COPY(rng->state, state);

	mov	eax, 8
	imul	rax, rax, 0
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rdx, QWORD PTR rng$[rsp]
	mov	rax, QWORD PTR state$[rsp+rax]
	mov	QWORD PTR [rdx+rcx], rax
	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 1
	mov	rdx, QWORD PTR rng$[rsp]
	mov	rax, QWORD PTR state$[rsp+rax]
	mov	QWORD PTR [rdx+rcx], rax

; 114  :   
; 115  :   // XSL-RR
; 116  :   uint64_t value = PCG64_HIGH(state) ^ PCG64_LOW(state);

	mov	eax, 8
	imul	rax, rax, 1
	mov	ecx, 8
	imul	rcx, rcx, 0
	mov	rcx, QWORD PTR state$[rsp+rcx]
	mov	rax, QWORD PTR state$[rsp+rax]
	xor	rax, rcx
	mov	QWORD PTR value$[rsp], rax

; 117  :   int rot = PCG64_HIGH(state) >> 58;

	mov	eax, 8
	imul	rax, rax, 1
	mov	rax, QWORD PTR state$[rsp+rax]
	shr	rax, 58					; 0000003aH
	mov	DWORD PTR rot$[rsp], eax

; 118  :   return PCG64_ROR(value, rot);

	mov	eax, DWORD PTR rot$[rsp]
	movzx	ecx, al
	mov	rax, QWORD PTR value$[rsp]
	ror	rax, cl

; 119  : }

	add	rsp, 88					; 00000058H
	ret	0
pcg64_next ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Provider$ = 48
Data$ = 80
Size$ = 88
EntropyGen PROC

; 240  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 241  :   HCRYPTPROV Provider = 0;

	mov	QWORD PTR Provider$[rsp], 0

; 242  :   CryptAcquireContextA(&Provider, 0, 0, 0, CRYPT_VERIFYCONTEXT);

	mov	DWORD PTR [rsp+32], -268435456		; f0000000H
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR Provider$[rsp]
	call	QWORD PTR __imp_CryptAcquireContextA

; 243  :   CryptGenRandom(Provider, (uint32_t)Size, (BYTE *)&Data);

	lea	r8, QWORD PTR Data$[rsp]
	mov	edx, DWORD PTR Size$[rsp]
	mov	rcx, QWORD PTR Provider$[rsp]
	call	QWORD PTR __imp_CryptGenRandom

; 244  :   CryptReleaseContext(Provider, 0);

	xor	edx, edx
	mov	rcx, QWORD PTR Provider$[rsp]
	call	QWORD PTR __imp_CryptReleaseContext

; 245  :   return;
; 246  : }

	add	rsp, 72					; 00000048H
	ret	0
EntropyGen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Src$ = 48
ByteCount$ = 56
MemoryClear PROC

; 234  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 235  :   memset(Src, 0, ByteCount);

	mov	r8, QWORD PTR ByteCount$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR Src$[rsp]
	call	memset

; 236  :   return;
; 237  : }

	add	rsp, 40					; 00000028H
	ret	0
MemoryClear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Dst$ = 48
Src$ = 56
ByteCount$ = 64
MemoryCopy PROC

; 229  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 230  :   memcpy(Dst, Src, ByteCount);

	mov	r8, QWORD PTR ByteCount$[rsp]
	mov	rdx, QWORD PTR Src$[rsp]
	mov	rcx, QWORD PTR Dst$[rsp]
	call	memcpy

; 231  :   return;
; 232  : }

	add	rsp, 40					; 00000028H
	ret	0
MemoryCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
ArgList$ = 32
String$ = 64
Format$ = 72
ConvertStrToValue PROC

; 221  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 222  :   va_list ArgList;
; 223  :   va_start(ArgList, Format);

	lea	rax, QWORD PTR Format$[rsp+8]
	mov	QWORD PTR ArgList$[rsp], rax

; 224  :   vsscanf(String, Format, ArgList);

	mov	r8, QWORD PTR ArgList$[rsp]
	mov	rdx, QWORD PTR Format$[rsp]
	mov	rcx, QWORD PTR String$[rsp]
	call	vsscanf

; 225  :   va_end(ArgList);

	mov	QWORD PTR ArgList$[rsp], 0

; 226  :   return;
; 227  : }

	add	rsp, 56					; 00000038H
	ret	0
ConvertStrToValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
ByteCountWriten$1 = 64
File$ = 72
Result$ = 80
__$ReturnAddress$ = 128
Path$ = 136
Buffer$ = 144
Size$ = 152
FileWrite PROC

; 207  : {

$LN5:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 104				; 00000068H

; 208  :   s8 Result = {0};

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 209  :   HANDLE File = CreateFileA((LPCSTR)Path, GENERIC_WRITE, FILE_SHARE_READ,

	mov	QWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	DWORD PTR [rsp+32], 2
	xor	r9d, r9d
	mov	r8d, 1
	mov	edx, 1073741824				; 40000000H
	mov	rcx, QWORD PTR Path$[rsp]
	call	QWORD PTR __imp_CreateFileA
	mov	QWORD PTR File$[rsp], rax

; 210  :                             0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
; 211  :   if(File)

	cmp	QWORD PTR File$[rsp], 0
	je	SHORT $LN2@FileWrite

; 212  :   {
; 213  :     uint32_t ByteCountWriten = 0;

	mov	DWORD PTR ByteCountWriten$1[rsp], 0

; 214  :     WriteFile(File, Buffer, Size, (LPDWORD)&ByteCountWriten, NULL);

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR ByteCountWriten$1[rsp]
	mov	r8d, DWORD PTR Size$[rsp]
	mov	rdx, QWORD PTR Buffer$[rsp]
	mov	rcx, QWORD PTR File$[rsp]
	call	QWORD PTR __imp_WriteFile
	jmp	SHORT $LN3@FileWrite
$LN2@FileWrite:

; 215  :   }else { printf("error"); }

	lea	rcx, OFFSET FLAT:$SG71339
	call	printf
$LN3@FileWrite:

; 216  :   return Result;

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 217  : }

	add	rsp, 104				; 00000068H
	pop	rdi
	pop	rsi
	ret	0
FileWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
ExpectedSize$1 = 64
File$ = 72
BytesRead$2 = 80
tv88 = 88
Result$ = 96
$S1$3 = 112
__$ReturnAddress$ = 160
Path$ = 168
Arena$ = 176
FileReadAll PROC

; 190  : {

$LN8:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 136				; 00000088H

; 191  :   s8 Result = {0};

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 16
	rep stosb

; 192  :   HANDLE File = CreateFileA((LPCSTR)Path, GENERIC_READ, FILE_SHARE_READ,

	mov	QWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	mov	r8d, 1
	mov	edx, -2147483648			; 80000000H
	mov	rcx, QWORD PTR Path$[rsp]
	call	QWORD PTR __imp_CreateFileA
	mov	QWORD PTR File$[rsp], rax

; 193  :                             0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
; 194  :   if(File)

	cmp	QWORD PTR File$[rsp], 0
	je	$LN4@FileReadAl

; 195  :   {
; 196  :     uint64_t ExpectedSize = FileGetSize(File);

	mov	rcx, QWORD PTR File$[rsp]
	call	FileGetSize
	mov	QWORD PTR ExpectedSize$1[rsp], rax

; 197  :     uint64_t BytesRead    = 0;

	mov	QWORD PTR BytesRead$2[rsp], 0

; 198  :     Result = (s8){ArenaPushArray(Arena, ExpectedSize, uint8_t), ExpectedSize};

	mov	rdx, QWORD PTR ExpectedSize$1[rsp]
	mov	rcx, QWORD PTR Arena$[rsp]
	call	ArenaPushBlock
	mov	QWORD PTR $S1$3[rsp], rax
	mov	rax, QWORD PTR ExpectedSize$1[rsp]
	mov	QWORD PTR $S1$3[rsp+8], rax
	lea	rax, QWORD PTR Result$[rsp]
	lea	rcx, QWORD PTR $S1$3[rsp]
	mov	rdi, rax
	mov	rsi, rcx
	mov	ecx, 16
	rep movsb

; 199  :     ReadFile(File, Result.Data, (uint32_t)ExpectedSize, (LPDWORD)&BytesRead, NULL);

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR BytesRead$2[rsp]
	mov	r8d, DWORD PTR ExpectedSize$1[rsp]
	mov	rdx, QWORD PTR Result$[rsp]
	mov	rcx, QWORD PTR File$[rsp]
	call	QWORD PTR __imp_ReadFile
$LN2@FileReadAl:

; 200  :     Assert(BytesRead == ExpectedSize);

	cmp	QWORD PTR BytesRead$2[rsp], 0
	jne	SHORT $LN6@FileReadAl
	mov	QWORD PTR tv88[rsp], 1
	jmp	SHORT $LN7@FileReadAl
$LN6@FileReadAl:
	mov	QWORD PTR tv88[rsp], 0
$LN7@FileReadAl:
	mov	rax, QWORD PTR ExpectedSize$1[rsp]
	cmp	QWORD PTR tv88[rsp], rax
	jne	SHORT $LN3@FileReadAl
	int	3
	jmp	SHORT $LN2@FileReadAl
$LN3@FileReadAl:

; 201  :     Result.Length = BytesRead;

	mov	rax, QWORD PTR BytesRead$2[rsp]
	mov	QWORD PTR Result$[rsp+8], rax

; 202  :     CloseHandle(File);

	mov	rcx, QWORD PTR File$[rsp]
	call	QWORD PTR __imp_CloseHandle
$LN4@FileReadAl:

; 203  :   }
; 204  :   return Result;

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 16
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 205  : }

	add	rsp, 136				; 00000088H
	pop	rdi
	pop	rsi
	ret	0
FileReadAll ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
tv72 = 32
Status$ = 36
Whatever$ = 40
Result$ = 48
File$ = 80
FileGetSize PROC

; 181  : {

$LN7:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 64					; 00000040H

; 182  :   LARGE_INTEGER Whatever = { 0 };

	lea	rax, QWORD PTR Whatever$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 183  :   uint64_t Result = 0;

	mov	QWORD PTR Result$[rsp], 0

; 184  :   uint32_t Status = GetFileSizeEx(File, &Whatever);

	lea	rdx, QWORD PTR Whatever$[rsp]
	mov	rcx, QWORD PTR File$[rsp]
	call	QWORD PTR __imp_GetFileSizeEx
	mov	DWORD PTR Status$[rsp], eax

; 185  :   Result = Whatever.QuadPart;

	mov	rax, QWORD PTR Whatever$[rsp]
	mov	QWORD PTR Result$[rsp], rax
$LN2@FileGetSiz:

; 186  :   Assert(Status != 0);

	cmp	DWORD PTR Status$[rsp], 0
	jne	SHORT $LN5@FileGetSiz
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN6@FileGetSiz
$LN5@FileGetSiz:
	mov	DWORD PTR tv72[rsp], 0
$LN6@FileGetSiz:
	cmp	DWORD PTR tv72[rsp], 0
	je	SHORT $LN3@FileGetSiz
	int	3
	jmp	SHORT $LN2@FileGetSiz
$LN3@FileGetSiz:

; 187  :   return Result;

	mov	rax, QWORD PTR Result$[rsp]

; 188  : }

	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
FileGetSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
r$ = 32
x$ = 64
SquareRoot PROC

; 171  : {

$LN3:
	movsd	QWORD PTR [rsp+8], xmm0
	sub	rsp, 56					; 00000038H

; 172  :   double r = sqrt(x);

	movsd	xmm0, QWORD PTR x$[rsp]
	movq	rcx, xmm0
	call	sqrt
	cvtsi2sd xmm0, eax
	movsd	QWORD PTR r$[rsp], xmm0

; 173  :   return r;

	movsd	xmm0, QWORD PTR r$[rsp]

; 174  : }

	add	rsp, 56					; 00000038H
	ret	0
SquareRoot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Start$ = 32
Result$ = 40
End$ = 48
Arena$ = 80
Size$ = 88
ArenaPushBlock PROC

; 148  : {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 149  :   void *Result = NULL;

	mov	QWORD PTR Result$[rsp], 0

; 150  :   uint64_t Start = (uint64_t)Arena->Base;

	mov	rax, QWORD PTR Arena$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR Start$[rsp], rax

; 151  :   uint64_t End   = Start + Arena->Capacity;

	mov	rax, QWORD PTR Arena$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	rcx, QWORD PTR Start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR End$[rsp], rax

; 152  :   if((Start + Arena->Offset + Size)<End)

	mov	rax, QWORD PTR Arena$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR Start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	add	rax, QWORD PTR Size$[rsp]
	cmp	rax, QWORD PTR End$[rsp]
	jae	SHORT $LN4@ArenaPushB

; 153  :   {
; 154  :     Result = (void *)(Start + Arena->Offset);

	mov	rax, QWORD PTR Arena$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	rcx, QWORD PTR Start$[rsp]
	add	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR Result$[rsp], rax

; 155  :     Arena->Offset += Size;

	mov	rax, QWORD PTR Arena$[rsp]
	mov	rax, QWORD PTR [rax+8]
	add	rax, QWORD PTR Size$[rsp]
	mov	rcx, QWORD PTR Arena$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 156  :   }

	jmp	SHORT $LN5@ArenaPushB
$LN4@ArenaPushB:

; 157  :   else
; 158  :   {
; 159  :     
; 160  :     printf("arena capacity is too small for resquested allocation");

	lea	rcx, OFFSET FLAT:$SG71282
	call	printf
$LN2@ArenaPushB:

; 161  :     Assert("Invalid Codepath");

	lea	rax, OFFSET FLAT:$SG71283
	test	rax, rax
	jne	SHORT $LN3@ArenaPushB
	int	3
	jmp	SHORT $LN2@ArenaPushB
$LN3@ArenaPushB:
$LN5@ArenaPushB:

; 162  :   }
; 163  :   return Result;

	mov	rax, QWORD PTR Result$[rsp]

; 164  : }

	add	rsp, 72					; 00000048H
	ret	0
ArenaPushBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Arena$ = 48
ArenaFree PROC

; 143  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 144  :   MemFree(Arena->Base);

	mov	rax, QWORD PTR Arena$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	MemFree

; 145  :   return;
; 146  : }

	add	rsp, 40					; 00000028H
	ret	0
ArenaFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Result$ = 32
$T1 = 56
__$ReturnAddress$ = 112
Capacity$ = 120
ArenaAlloc PROC

; 138  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 88					; 00000058H

; 139  :   arena Result = ArenaInit(MemAlloc(Capacity), Capacity);

	mov	rcx, QWORD PTR Capacity$[rsp]
	call	MemAlloc
	mov	r8, QWORD PTR Capacity$[rsp]
	mov	rdx, rax
	lea	rcx, QWORD PTR $T1[rsp]
	call	ArenaInit
	lea	rcx, QWORD PTR Result$[rsp]
	mov	rdi, rcx
	mov	rsi, rax
	mov	ecx, 24
	rep movsb

; 140  :   return Result;

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 24
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 141  : }

	add	rsp, 88					; 00000058H
	pop	rdi
	pop	rsi
	ret	0
ArenaAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Result$ = 0
__$ReturnAddress$ = 64
Memory$ = 72
Capacity$ = 80
ArenaInit PROC

; 133  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 134  :   arena Result = { .Base = Memory, .Capacity = Capacity, .Offset = 0 };

	mov	rax, QWORD PTR Memory$[rsp]
	mov	QWORD PTR Result$[rsp], rax
	mov	QWORD PTR Result$[rsp+8], 0
	mov	rax, QWORD PTR Capacity$[rsp]
	mov	QWORD PTR Result$[rsp+16], rax

; 135  :   return Result;

	lea	rax, QWORD PTR Result$[rsp]
	mov	rdi, QWORD PTR __$ReturnAddress$[rsp]
	mov	rsi, rax
	mov	ecx, 24
	rep movsb
	mov	rax, QWORD PTR __$ReturnAddress$[rsp]

; 136  : }

	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
ArenaInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Ptr$ = 48
MemFree	PROC

; 121  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 122  :   VirtualFree(Ptr, 0, MEM_RELEASE);

	mov	r8d, 32768				; 00008000H
	xor	edx, edx
	mov	rcx, QWORD PTR Ptr$[rsp]
	call	QWORD PTR __imp_VirtualFree

; 123  :   return;
; 124  : }

	add	rsp, 40					; 00000028H
	ret	0
MemFree	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Ptr$ = 32
Size$ = 64
MemAlloc PROC

; 115  : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 116  :   //we get commit and entire 4k page
; 117  :   void *Ptr = VirtualAlloc(0, Size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

	mov	r9d, 4
	mov	r8d, 12288				; 00003000H
	mov	rdx, QWORD PTR Size$[rsp]
	xor	ecx, ecx
	call	QWORD PTR __imp_VirtualAlloc
	mov	QWORD PTR Ptr$[rsp], rax

; 118  :   return Ptr;

	mov	rax, QWORD PTR Ptr$[rsp]

; 119  : }

	add	rsp, 56					; 00000038H
	ret	0
MemAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Result$ = 0
Target$ = 32
Value$ = 40
LockedSetAndGetLastValue PROC

; 108  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 109  :   uint64_t Result = InterlockedExchange64((volatile LONG64 *)Target, Value);

	mov	rax, QWORD PTR Value$[rsp]
	mov	rcx, QWORD PTR Target$[rsp]
	xchg	QWORD PTR [rcx], rax
	mov	QWORD PTR Result$[rsp], rax

; 110  :   return Result;

	mov	rax, QWORD PTR Result$[rsp]

; 111  : }

	add	rsp, 24
	ret	0
LockedSetAndGetLastValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Result$ = 0
Target$ = 32
Addend$ = 40
LockedAddAndGetLastValue PROC

; 103  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 104  :   uint64_t Result = InterlockedExchangeAdd64((volatile LONG64 *)Target, Addend);

	mov	rax, QWORD PTR Addend$[rsp]
	mov	rcx, QWORD PTR Target$[rsp]
	lock xadd QWORD PTR [rcx], rax
	mov	QWORD PTR Result$[rsp], rax

; 105  :   return Result;

	mov	rax, QWORD PTR Result$[rsp]

; 106  : }

	add	rsp, 24
	ret	0
LockedAddAndGetLastValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
EventSignal$ = 48
ThreadWaitForEventSignal PROC

; 96   : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 97   :   WaitForSingleObject((HANDLE)EventSignal, INFINITE); 

	mov	edx, -1					; ffffffffH
	mov	rcx, QWORD PTR EventSignal$[rsp]
	call	QWORD PTR __imp_WaitForSingleObject

; 98   :   return;
; 99   : }

	add	rsp, 40					; 00000028H
	ret	0
ThreadWaitForEventSignal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
EventHandle$ = 32
EventName$ = 64
ThreadCreateEvent PROC

; 91   : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 92   :   uint64_t EventHandle = (uint64_t)CreateEvent(NULL, TRUE, FALSE, TEXT(EventName));

	mov	r9, QWORD PTR EventName$[rsp]
	xor	r8d, r8d
	mov	edx, 1
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateEventA
	mov	QWORD PTR EventHandle$[rsp], rax

; 93   :   return EventHandle;

	mov	rax, QWORD PTR EventHandle$[rsp]

; 94   : }

	add	rsp, 56					; 00000038H
	ret	0
ThreadCreateEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
BeginSignal$ = 48
ThreadBeginWork PROC

; 85   : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 86   :   if(SetEvent((HANDLE)BeginSignal)) { fprintf(stderr, "work begin signal set.\n"); }

	mov	rcx, QWORD PTR BeginSignal$[rsp]
	call	QWORD PTR __imp_SetEvent
	test	eax, eax
	je	SHORT $LN2@ThreadBegi
	mov	ecx, 2
	call	__acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG71206
	mov	rcx, rax
	call	fprintf
	jmp	SHORT $LN3@ThreadBegi
$LN2@ThreadBegi:

; 87   :   else                              { fprintf(stderr, "Error setting work queue begin signal.\n"); }

	mov	ecx, 2
	call	__acrt_iob_func
	lea	rdx, OFFSET FLAT:$SG71207
	mov	rcx, rax
	call	fprintf
$LN3@ThreadBegi:

; 88   :   return;
; 89   : }

	add	rsp, 40					; 00000028H
	ret	0
ThreadBeginWork ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
ThreadHandles$ = 48
ThreadCount$ = 56
ThreadSync PROC

; 80   : {

$LN3:
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 81   :   WaitForMultipleObjects(ThreadCount, (HANDLE *)ThreadHandles, TRUE, INFINITE);

	mov	r9d, -1					; ffffffffH
	mov	r8d, 1
	mov	rdx, QWORD PTR ThreadHandles$[rsp]
	mov	ecx, DWORD PTR ThreadCount$[rsp]
	call	QWORD PTR __imp_WaitForMultipleObjects

; 82   :   return;
; 83   : }

	add	rsp, 40					; 00000028H
	ret	0
ThreadSync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
ThreadKill PROC

; 75   : {

$LN3:
	sub	rsp, 40					; 00000028H

; 76   :   ExitThread(0);

	xor	ecx, ecx
	call	QWORD PTR __imp_ExitThread
$LN2@ThreadKill:

; 77   :   return;
; 78   : }

	add	rsp, 40					; 00000028H
	ret	0
ThreadKill ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
ThreadId$ = 48
ThreadHandle$ = 56
Param$ = 80
ThreadProc$ = 88
ThreadCreate PROC

; 69   : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 70   :   DWORD ThreadId;
; 71   :   HANDLE ThreadHandle = CreateThread(0, 0, ThreadProc, Param, 0, &ThreadId);

	lea	rax, QWORD PTR ThreadId$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	DWORD PTR [rsp+32], 0
	mov	r9, QWORD PTR Param$[rsp]
	mov	r8, QWORD PTR ThreadProc$[rsp]
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_CreateThread
	mov	QWORD PTR ThreadHandle$[rsp], rax

; 72   :   return (uint64_t)ThreadHandle;

	mov	rax, QWORD PTR ThreadHandle$[rsp]

; 73   : }

	add	rsp, 72					; 00000048H
	ret	0
ThreadCreate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Delta$ = 32
Result$ = 40
StartTick$ = 64
EndTick$ = 72
TimerGetSecondsElepsed PROC

; 60   : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 61   :   if(!GlobalTimer.IsInitialized) TimerInit();

	cmp	DWORD PTR GlobalTimer, 0
	jne	SHORT $LN2@TimerGetSe
	call	TimerInit
$LN2@TimerGetSe:

; 62   :   uint64_t Delta = EndTick-StartTick;

	mov	rax, QWORD PTR StartTick$[rsp]
	mov	rcx, QWORD PTR EndTick$[rsp]
	sub	rcx, rax
	mov	rax, rcx
	mov	QWORD PTR Delta$[rsp], rax

; 63   :   double Result = (Delta*1.0)/(double)GlobalTimer.Frequency;

	mov	rax, QWORD PTR Delta$[rsp]
	test	rax, rax
	jl	SHORT $LN6@TimerGetSe
	cvtsi2sd xmm0, rax
	jmp	SHORT $LN7@TimerGetSe
$LN6@TimerGetSe:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm1, rcx
	addsd	xmm1, xmm1
	movaps	xmm0, xmm1
$LN7@TimerGetSe:
	mulsd	xmm0, QWORD PTR __real@3ff0000000000000
	mov	rax, QWORD PTR GlobalTimer+8
	test	rax, rax
	jl	SHORT $LN4@TimerGetSe
	cvtsi2sd xmm1, rax
	jmp	SHORT $LN5@TimerGetSe
$LN4@TimerGetSe:
	mov	rcx, rax
	shr	rcx, 1
	and	rax, 1
	or	rcx, rax
	cvtsi2sd xmm2, rcx
	addsd	xmm2, xmm2
	movaps	xmm1, xmm2
$LN5@TimerGetSe:
	divsd	xmm0, xmm1
	movsd	QWORD PTR Result$[rsp], xmm0

; 64   :   return Result;

	movsd	xmm0, QWORD PTR Result$[rsp]

; 65   : }

	add	rsp, 56					; 00000038H
	ret	0
TimerGetSecondsElepsed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Tick$ = 32
Result$ = 40
TimerGetTick PROC

; 53   : {

$LN3:
	push	rdi
	sub	rsp, 48					; 00000030H

; 54   :   LARGE_INTEGER Tick = {0};

	lea	rax, QWORD PTR Tick$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 55   :   QueryPerformanceCounter(&Tick);

	lea	rcx, QWORD PTR Tick$[rsp]
	call	QWORD PTR __imp_QueryPerformanceCounter

; 56   :   uint64_t Result = Tick.QuadPart;

	mov	rax, QWORD PTR Tick$[rsp]
	mov	QWORD PTR Result$[rsp], rax

; 57   :   return Result;

	mov	rax, QWORD PTR Result$[rsp]

; 58   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
TimerGetTick ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Freq$ = 32
TimerInit PROC

; 46   : {

$LN3:
	push	rdi
	sub	rsp, 48					; 00000030H

; 47   :   LARGE_INTEGER Freq = {0};

	lea	rax, QWORD PTR Freq$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 48   :   QueryPerformanceFrequency(&Freq);

	lea	rcx, QWORD PTR Freq$[rsp]
	call	QWORD PTR __imp_QueryPerformanceFrequency

; 49   :   GlobalTimer.Frequency = Freq.QuadPart;

	mov	rax, QWORD PTR Freq$[rsp]
	mov	QWORD PTR GlobalTimer+8, rax

; 50   :   GlobalTimer.IsInitialized = 1;

	mov	DWORD PTR GlobalTimer, 1

; 51   : }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
TimerInit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
KillProcess PROC

; 33   : {

$LN3:
	sub	rsp, 40					; 00000028H

; 34   :   ExitProcess(1);

	mov	ecx, 1
	call	QWORD PTR __imp_ExitProcess
$LN2@KillProces:

; 35   :   return;
; 36   : }

	add	rsp, 40					; 00000028H
	ret	0
KillProcess ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File F:\Dev\parallel-algos\src\common.h
_TEXT	SEGMENT
Length$ = 32
Result$ = 36
SystemInfo$ = 40
ProcessorInfo$ = 96
GetLogicalCoreCount PROC

; 22   : {

$LN3:
	push	rdi
	sub	rsp, 176				; 000000b0H

; 23   :   //https://stackoverflow.com/questions/28893786/how-to-get-the-number-of-actual-cores-on-the-cpu-on-windows
; 24   :   SYSTEM_INFO SystemInfo = {0};

	lea	rax, QWORD PTR SystemInfo$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 48					; 00000030H
	rep stosb

; 25   :   SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX ProcessorInfo= {0};

	lea	rax, QWORD PTR ProcessorInfo$[rsp]
	mov	rdi, rax
	xor	eax, eax
	mov	ecx, 80					; 00000050H
	rep stosb

; 26   :   DWORD Length = 0;

	mov	DWORD PTR Length$[rsp], 0

; 27   :   GetSystemInfo(&SystemInfo);

	lea	rcx, QWORD PTR SystemInfo$[rsp]
	call	QWORD PTR __imp_GetSystemInfo

; 28   :   GetLogicalProcessorInformationEx(RelationProcessorPackage, &ProcessorInfo, &Length);

	lea	r8, QWORD PTR Length$[rsp]
	lea	rdx, QWORD PTR ProcessorInfo$[rsp]
	mov	ecx, 3
	call	QWORD PTR __imp_GetLogicalProcessorInformationEx

; 29   :   uint32_t Result = SystemInfo.dwNumberOfProcessors;

	mov	eax, DWORD PTR SystemInfo$[rsp+32]
	mov	DWORD PTR Result$[rsp], eax

; 30   :   return Result;

	mov	eax, DWORD PTR Result$[rsp]

; 31   : }

	add	rsp, 176				; 000000b0H
	pop	rdi
	ret	0
GetLogicalCoreCount ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT vsscanf
_TEXT	SEGMENT
_Buffer$ = 48
_Format$ = 56
_ArgList$ = 64
vsscanf	PROC						; COMDAT

; 2168 :     {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2169 :         return _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Buffer$[rsp]
	call	_vsscanf_l

; 2170 :     }

	add	rsp, 40					; 00000028H
	ret	0
vsscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 2153 :         return __stdio_common_vsscanf(

	call	__local_stdio_scanf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+40], rcx
	mov	rcx, QWORD PTR _Locale$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Format$[rsp]
	mov	r8, -1
	mov	rdx, QWORD PTR _Buffer$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

	add	rsp, 56					; 00000038H
	ret	0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	__acrt_iob_func
	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, rax
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 963  :     }

	add	rsp, 56					; 00000038H
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 837  :     {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 56					; 00000038H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);

	lea	rax, QWORD PTR _Format$[rsp+8]
	mov	QWORD PTR _ArgList$[rsp], rax

; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

	mov	r9, QWORD PTR _ArgList$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR _Format$[rsp]
	mov	rcx, QWORD PTR _Stream$[rsp]
	call	_vfprintf_l
	mov	DWORD PTR _Result$[rsp], eax

; 842  :         __crt_va_end(_ArgList);

	mov	QWORD PTR _ArgList$[rsp], 0

; 843  :         return _Result;

	mov	eax, DWORD PTR _Result$[rsp]

; 844  :     }

	add	rsp, 56					; 00000038H
	ret	0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	mov	rcx, QWORD PTR _ArgList$[rsp]
	mov	QWORD PTR [rsp+32], rcx
	mov	r9, QWORD PTR _Locale$[rsp]
	mov	r8, QWORD PTR _Format$[rsp]
	mov	rdx, QWORD PTR _Stream$[rsp]
	mov	rcx, QWORD PTR [rax]
	call	__stdio_common_vfprintf

; 646  :     }

	add	rsp, 56					; 00000038H
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

	ret	0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
